<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Neural Cellular Automata</title>
    <style>
        .flex {
            display: flex;
        }

        .g-1 {
            flex-grow: 1;
        }
    </style>
</head>

<body>
    <div class="flex">
        <div class="g-1"></div>
        <canvas style="display:inline-block; width: 60vmin; height: 60vmin; image-rendering: pixelated;"></canvas>
        <div class="g-1"></div>
    </div>
    <script id="v" type="x/glsl">
        #version 300 es
        in vec2 position;
        void main() {
          gl_Position = vec4(position, 0.0, 1.0);
        }
      </script>
    <script id="f" type="x/glsl">
        #version 300 es
        #define TAU 6.28318530718
        precision highp float;
        
        uniform sampler2D uTex;
        
        uniform float time;
        uniform vec2 rez;
        
        out vec4 outColor;
        
        uniform float u_kernel[9];
      
        float activation(float f){ return max(0.0,f); }
        vec4 getCell(vec2 p){ return texture(uTex, p / rez); }
        
        void main() {
          vec2 p = gl_FragCoord.xy;
          
          vec3 v = vec3(-1,0,1);
          float sum
            = getCell(p + vec2( 1.,-1.)).r * u_kernel[0] 
            + getCell(p + vec2( 0.,-1.)).r * u_kernel[1]
            + getCell(p + vec2(-1.,-1.)).r * u_kernel[2]
            + getCell(p + vec2( 1., 0.)).r * u_kernel[3]
            + getCell(p + vec2( 0., 0.)).r * u_kernel[4]
            + getCell(p + vec2(-1., 0.)).r * u_kernel[5]
            + getCell(p + vec2( 1., 1.)).r * u_kernel[6]
            + getCell(p + vec2( 0., 1.)).r * u_kernel[7]
            + getCell(p + vec2(-1., 1.)).r * u_kernel[8];
          
          float x = activation(sum);
          vec4 c = getCell(p);
          c.r = x;
          c.g = x;
          c.b = x;
          c.a = 1.0;
          outColor = c;
        }
      </script>
    <script>
        const cvs = document.querySelector('canvas'),
            width = cvs.width = 256,
            height = cvs.height = 256,
            gl = cvs.getContext('webgl2');

        var ext = gl.getExtension('EXT_color_buffer_float');
        if (!ext) {
            throw '32-bit floating point texture not supported';
        }

        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, document.querySelector('#v').textContent.trim());
        gl.compileShader(vs);

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.querySelector('#f').textContent.trim());
        gl.compileShader(fs);

        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
            console.warn(gl.getShaderInfoLog(fs));

        var program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 3, 3, -1]), gl.STATIC_DRAW);

        var pL = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(pL);
        gl.vertexAttribPointer(pL, 2, gl.FLOAT, false, 0, 0);

        function createTexture() {
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, null);
            return tex;
        }

        var tex1 = createTexture();
        var tex2 = createTexture();

        var fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex1, 0);

        var tL = gl.getUniformLocation(program, 'time');
        var tR = gl.getUniformLocation(program, 'rez');
        var uTex = gl.getUniformLocation(program, 'uTex');

        let kernel = [];
        for (let i = 0; i < 9; i++) {
            kernel.push({
                L: gl.getUniformLocation(program, `u_kernel[${i}]`),
                value: 2 * Math.random() - 1,
                set() { gl.uniform1f(this.L, this.value); }
            })
        }

        setInterval(() => {
            var data = new Float32Array(width * height * 4);
            for (let i = 0; i < data.length; i++) data[i] = 1 - 2 * Math.random();
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, data);

            kernel.forEach(k => k.value = 2 * Math.random() - 1);
        }, 5000);

        (function render() {
            var time = performance.now() * 0.001;
            gl.uniform1f(tL, time);
            gl.uniform2f(tR, width, height);
            kernel.forEach(k => k.set());

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex1);
            gl.uniform1i(uTex, 0);

            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            gl.bindTexture(gl.TEXTURE_2D, tex2);
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            [tex1, tex2] = [tex2, tex1];

            requestAnimationFrame(render);
        })();

    </script>
</body>

</html>